diff --git a/discover/gpu.go b/discover/gpu.go
index 2e83b74f..1b6a3f07 100644
--- a/discover/gpu.go
+++ b/discover/gpu.go
@@ -38,6 +38,11 @@ type oneapiHandles struct {
 	deviceCount int
 }
 
+type vulkanHandles struct {
+	vulkan      *C.vk_handle_t
+	deviceCount int
+}
+
 const (
 	cudaMinimumMemory = 457 * format.MebiByte
 	rocmMinimumMemory = 457 * format.MebiByte
@@ -52,9 +57,12 @@ var (
 	nvcudaLibPath string
 	cudartLibPath string
 	oneapiLibPath string
+	vulkanLibPath string
+	libcapLibPath string
 	nvmlLibPath   string
 	rocmGPUs      []RocmGPUInfo
 	oneapiGPUs    []OneapiGPUInfo
+	vulkanGPUs    []VulkanGPUInfo
 
 	// If any discovered GPUs are incompatible, report why
 	unsupportedGPUs []UnsupportedGPUInfo
@@ -183,6 +191,26 @@ func initOneAPIHandles() *oneapiHandles {
 	return oHandles
 }
 
+// Note: gpuMutex must already be held
+func initVulkanHandles() *vulkanHandles {
+	vHandles := &vulkanHandles{}
+
+	// Short Circuit if we already know which library to use
+	if vulkanLibPath != "" && libcapLibPath != "" {
+		vHandles.deviceCount, vHandles.vulkan, _, _ = LoadVulkanMgmt([]string{vulkanLibPath}, []string{libcapLibPath})
+		return vHandles
+	}
+
+	vulkanPaths := FindGPULibs(VulkanMgmtName, VulkanGlobs)
+	libcapPaths := FindLibCapLibs()
+
+	if len(vulkanPaths) > 0 && len(libcapPaths) > 0 {
+		vHandles.deviceCount, vHandles.vulkan, vulkanLibPath, libcapLibPath = LoadVulkanMgmt(vulkanPaths, libcapPaths)
+	}
+
+	return vHandles
+}
+
 func GetCPUInfo() GpuInfoList {
 	gpuMutex.Lock()
 	if !bootstrapped {
@@ -202,6 +230,7 @@ func GetGPUInfo() GpuInfoList {
 	needRefresh := true
 	var cHandles *cudaHandles
 	var oHandles *oneapiHandles
+	var vHandles *vulkanHandles
 	defer func() {
 		if cHandles != nil {
 			if cHandles.cudart != nil {
@@ -220,6 +249,11 @@ func GetGPUInfo() GpuInfoList {
 				C.oneapi_release(*oHandles.oneapi)
 			}
 		}
+		if vHandles != nil {
+			if vHandles.vulkan != nil {
+				C.vk_release(*vHandles.vulkan)
+			}
+		}
 	}()
 
 	if !bootstrapped {
@@ -383,12 +417,45 @@ func GetGPUInfo() GpuInfoList {
 			}
 		}
 
+		// Vulkan
+		vHandles = initVulkanHandles()
+		for i := range vHandles.deviceCount {
+			if vHandles.vulkan != nil {
+				gpuInfo := VulkanGPUInfo{
+					GpuInfo: GpuInfo{
+						Library: "vulkan",
+					},
+					index: i,
+				}
+
+				C.vk_check_vram(*vHandles.vulkan, C.int(i), &memInfo)
+				if memInfo.err != nil {
+					slog.Info("error looking up vulkan GPU memory", "error", C.GoString(memInfo.err))
+					C.free(unsafe.Pointer(memInfo.err))
+					continue
+				}
+
+				gpuInfo.TotalMemory = uint64(memInfo.total)
+				gpuInfo.FreeMemory = uint64(memInfo.free)
+				gpuInfo.ID = C.GoString(&memInfo.gpu_id[0])
+				gpuInfo.Compute = fmt.Sprintf("%d.%d", memInfo.major, memInfo.minor)
+				gpuInfo.MinimumMemory = 0
+				gpuInfo.DependencyPath = depPaths
+				gpuInfo.Name = C.GoString(&memInfo.gpu_name[0])
+				gpuInfo.DriverMajor = int(memInfo.major)
+				gpuInfo.DriverMinor = int(memInfo.minor)
+
+				// TODO potentially sort on our own algorithm instead of what the underlying GPU library does...
+				vulkanGPUs = append(vulkanGPUs, gpuInfo)
+			}
+		}
+
 		rocmGPUs, err = AMDGetGPUInfo()
 		if err != nil {
 			bootstrapErrors = append(bootstrapErrors, err)
 		}
 		bootstrapped = true
-		if len(cudaGPUs) == 0 && len(rocmGPUs) == 0 && len(oneapiGPUs) == 0 {
+		if len(cudaGPUs) == 0 && len(rocmGPUs) == 0 && len(oneapiGPUs) == 0 && len(vulkanGPUs) == 0 {
 			slog.Info("no compatible GPUs were discovered")
 		}
 
@@ -488,6 +555,22 @@ func GetGPUInfo() GpuInfoList {
 			oneapiGPUs[i].FreeMemory = uint64(memInfo.free)
 		}
 
+		if vHandles == nil && len(vulkanGPUs) > 0 {
+			vHandles = initVulkanHandles()
+		}
+		for i, gpu := range vulkanGPUs {
+			if vHandles.vulkan == nil {
+				// shouldn't happen
+				slog.Warn("nil vulkan handle with device count", "count", oHandles.deviceCount)
+				continue
+			}
+			C.vk_check_vram(*vHandles.vulkan, C.int(gpu.index), &memInfo)
+			// TODO - convert this to MinimumMemory based on testing...
+			var totalFreeMem float64 = float64(memInfo.free) * 0.95 // work-around: leave some reserve vram for mkl lib used in ggml-sycl backend.
+			memInfo.free = C.uint64_t(totalFreeMem)
+			vulkanGPUs[i].FreeMemory = uint64(memInfo.free)
+		}
+
 		err = RocmGPUInfoList(rocmGPUs).RefreshFreeMemory()
 		if err != nil {
 			slog.Debug("problem refreshing ROCm free memory", "error", err)
@@ -504,6 +587,9 @@ func GetGPUInfo() GpuInfoList {
 	for _, gpu := range oneapiGPUs {
 		resp = append(resp, gpu.GpuInfo)
 	}
+	for _, gpu := range vulkanGPUs {
+		resp = append(resp, gpu.GpuInfo)
+	}
 	if len(resp) == 0 {
 		resp = append(resp, cpus[0].GpuInfo)
 	}
@@ -687,6 +773,29 @@ func loadOneapiMgmt(oneapiLibPaths []string) (int, *C.oneapi_handle_t, string, e
 	return 0, nil, "", err
 }
 
+func LoadVulkanMgmt(vulkanLibPaths []string, capLibPaths []string) (int, *C.vk_handle_t, string, string) {
+	var resp C.vk_init_resp_t
+	resp.ch.verbose = getVerboseState()
+	for _, vkLibPath := range vulkanLibPaths {
+		for _, capLibPath := range capLibPaths {
+			vkLib := C.CString(vkLibPath)
+			capLib := C.CString(capLibPath)
+			defer C.free(unsafe.Pointer(vkLib))
+			defer C.free(unsafe.Pointer(capLib))
+
+			C.vk_init(vkLib, capLib, &resp)
+			if resp.err != nil {
+				slog.Debug("Unable to load vulkan", "library", vkLibPath, capLibPath, "error", C.GoString(resp.err))
+				C.free(unsafe.Pointer(resp.err))
+			} else {
+				return int(resp.num_devices), &resp.ch, vkLibPath, capLibPath
+			}
+		}
+	}
+
+	return 0, nil, "", ""
+}
+
 func getVerboseState() C.uint16_t {
 	if envconfig.Debug() {
 		return C.uint16_t(1)
@@ -709,6 +818,8 @@ func (l GpuInfoList) GetVisibleDevicesEnv() (string, string) {
 		return rocmGetVisibleDevicesEnv(l)
 	case "oneapi":
 		return oneapiGetVisibleDevicesEnv(l)
+	case "vulkan":
+		return vkGetVisibleDevicesEnv(l)
 	default:
 		slog.Debug("no filter required for library " + l[0].Library)
 		return "", ""
diff --git a/discover/gpu_info.h b/discover/gpu_info.h
index 094b791a..d36aff25 100644
--- a/discover/gpu_info.h
+++ b/discover/gpu_info.h
@@ -65,6 +65,7 @@ void cpu_check_ram(mem_info_t *resp);
 #include "gpu_info_nvcuda.h"
 #include "gpu_info_nvml.h"
 #include "gpu_info_oneapi.h"
+#include "gpu_info_vulkan.h"
 
 #endif  // __GPU_INFO_H__
 #endif  // __APPLE__
diff --git a/discover/gpu_info_vulkan.c b/discover/gpu_info_vulkan.c
new file mode 100644
index 00000000..e868dcc1
--- /dev/null
+++ b/discover/gpu_info_vulkan.c
@@ -0,0 +1,228 @@
+#include "gpu_info_vulkan.h"
+
+#include <string.h>
+
+int check_perfmon(vk_handle_t* rh) {
+#ifdef __linux__
+  cap_t caps;
+  const cap_value_t cap_list[1] = {CAP_PERFMON};
+
+  caps = (*rh->cap_get_proc)();
+  if (caps == NULL)
+    return -1;
+
+  if ((*rh->cap_set_flag)(caps, CAP_EFFECTIVE, 1, cap_list, CAP_SET) == -1)
+    return -1;
+
+  if ((*rh->cap_set_proc)(caps) == -1)
+    return -1;
+
+  if ((*rh->cap_free)(caps) == -1)
+    return -1;
+#endif
+
+  return 0;
+}
+
+int support_memory_budget(vk_handle_t* rh, VkPhysicalDevice device) {
+  VkPhysicalDeviceProperties properties;
+  (*rh->vkGetPhysicalDeviceProperties)(device, &properties);
+  uint32_t extensionCount;
+  (*rh->vkEnumerateDeviceExtensionProperties)(device, NULL, &extensionCount, NULL);
+  VkExtensionProperties* extensions = malloc(extensionCount * sizeof(VkExtensionProperties));
+  (*rh->vkEnumerateDeviceExtensionProperties)(device, NULL, &extensionCount, extensions);
+  for (int j = 0; j < extensionCount; j++) {
+    if (strcmp(extensions[j].extensionName, VK_EXT_MEMORY_BUDGET_EXTENSION_NAME) == 0) {
+      return 1;
+    }
+  }
+  return 0;
+}
+
+void vk_init(char* vk_lib_path, char* cap_lib_path, vk_init_resp_t *resp) {
+  const int buflen = 256;
+  char buf[buflen + 1];
+  int i;
+
+  struct lookup {
+    int is_cap;
+    char *s;
+    void **p;
+  } l[] = {
+#ifdef __linux__
+      {1, "cap_get_proc", (void *)&resp->ch.cap_get_proc},
+      {1, "cap_get_bound", (void *)&resp->ch.cap_get_bound},
+      {1, "cap_set_flag", (void *)&resp->ch.cap_set_flag},
+      {1, "cap_set_proc", (void *)&resp->ch.cap_set_proc},
+      {1, "cap_free", (void *)&resp->ch.cap_free},
+#endif
+      {0, "vkGetPhysicalDeviceProperties", (void *)&resp->ch.vkGetPhysicalDeviceProperties},
+      {0, "vkEnumerateDeviceExtensionProperties", (void *)&resp->ch.vkEnumerateDeviceExtensionProperties},
+      {0, "vkCreateInstance", (void *)&resp->ch.vkCreateInstance},
+      {0, "vkEnumeratePhysicalDevices", (void *)&resp->ch.vkEnumeratePhysicalDevices},
+      {0, "vkGetPhysicalDeviceMemoryProperties2", (void *)&resp->ch.vkGetPhysicalDeviceMemoryProperties2},
+      {0, "vkDestroyInstance", (void *)&resp->ch.vkDestroyInstance},
+      {0, NULL, NULL},
+  };
+
+  resp->ch.vk_handle = LOAD_LIBRARY(vk_lib_path, RTLD_LAZY);
+  if (!resp->ch.vk_handle) {
+    char *msg = LOAD_ERR();
+    LOG(resp->ch.verbose, "library %s load err: %s\n", vk_lib_path, msg);
+    snprintf(buf, buflen,
+            "Unable to load %s library to query for Vulkan GPUs: %s",
+            vk_lib_path, msg);
+    free(msg);
+    resp->err = strdup(buf);
+    return;
+  }
+
+#ifdef __linux__
+  resp->ch.cap_handle = LOAD_LIBRARY(cap_lib_path, RTLD_LAZY);
+  if (!resp->ch.cap_handle) {
+    char *msg = LOAD_ERR();
+    LOG(resp->ch.verbose, "library %s load err: %s\n", cap_lib_path, msg);
+    snprintf(buf, buflen,
+            "Unable to load %s library to query for Vulkan GPUs: %s",
+            cap_lib_path, msg);
+    free(msg);
+    resp->err = strdup(buf);
+    return;
+  }
+#endif
+
+  for (i = 0; l[i].s != NULL; i++) {
+    if (l[i].is_cap)
+#ifdef __linux__
+      *l[i].p = LOAD_SYMBOL(resp->ch.cap_handle, l[i].s);
+#else
+      continue;
+#endif
+    else
+      *l[i].p = LOAD_SYMBOL(resp->ch.vk_handle, l[i].s);
+    if (!*l[i].p) {
+      char *msg = LOAD_ERR();
+      LOG(resp->ch.verbose, "dlerr: %s\n", msg);
+      if (l[i].is_cap) {
+        UNLOAD_LIBRARY(resp->ch.cap_handle);
+        resp->ch.cap_handle = NULL;
+      } else {
+        UNLOAD_LIBRARY(resp->ch.vk_handle);
+        resp->ch.vk_handle = NULL;
+      }
+      snprintf(buf, buflen, "symbol lookup for %s failed: %s", l[i].s,
+              msg);
+      free(msg);
+      resp->err = strdup(buf);
+      return;
+    }
+  }
+
+  if (check_perfmon(&resp->ch) != 0) {
+    resp->err = strdup("performance monitoring is not allowed. Please enable CAP_PERFMON or run as root to use Vulkan.");
+    LOG(resp->ch.verbose, "vulkan: %s", resp->err);
+    return;
+  }
+
+  VkInstance instance;
+  VkApplicationInfo appInfo = {};
+  appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
+  appInfo.pNext = NULL;
+  appInfo.pApplicationName = "Ollama";
+  appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
+  appInfo.pEngineName = "No Engine";
+  appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);
+  appInfo.apiVersion = VK_API_VERSION_1_2;
+  VkInstanceCreateInfo createInfo = {};
+  createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
+  createInfo.pNext = NULL;
+  createInfo.flags = 0;
+  createInfo.enabledExtensionCount = 1;
+  const char* extensions[] = { VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME };
+  createInfo.ppEnabledExtensionNames = extensions;
+  createInfo.pApplicationInfo = &appInfo;
+  VkResult result = (*resp->ch.vkCreateInstance)(&createInfo, NULL, &instance);
+  if (result != VK_SUCCESS) {
+    resp->err = strdup("failed to create instance");
+    return;
+  }
+
+  uint32_t deviceCount;
+  result = (*resp->ch.vkEnumeratePhysicalDevices)(instance, &deviceCount, NULL);
+  if (result != VK_SUCCESS) {
+    resp->err = strdup("failed to enumerate physical devices");
+    return;
+  }
+
+  resp->err = NULL;
+  resp->ch.vk = instance;
+  resp->ch.num_devices = deviceCount;
+  resp->num_devices = deviceCount;
+}
+
+void vk_check_vram(vk_handle_t rh, int i, mem_info_t *resp) {
+  VkInstance instance = rh.vk;
+  uint32_t deviceCount = rh.num_devices;
+
+  VkPhysicalDevice* devices = malloc(deviceCount * sizeof(VkPhysicalDevice));
+  VkResult result = (*rh.vkEnumeratePhysicalDevices)(instance, &deviceCount, devices);
+  if (result != VK_SUCCESS) {
+    resp->err = strdup("failed to enumerate physical devices");
+    return;
+  }
+
+  VkPhysicalDeviceProperties properties;
+  (*rh.vkGetPhysicalDeviceProperties)(devices[i], &properties);
+  int supports_budget = support_memory_budget(&rh, devices[i]);
+  if (!supports_budget) {
+    resp->err = strdup("device does not support memory budget");
+    return;
+  }
+  if (properties.deviceType == VK_PHYSICAL_DEVICE_TYPE_CPU) {
+    resp->err = strdup("device is a CPU");
+    return;
+  }
+
+  VkPhysicalDeviceMemoryBudgetPropertiesEXT physical_device_memory_budget_properties;
+  physical_device_memory_budget_properties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT;
+  physical_device_memory_budget_properties.pNext = NULL;
+
+  VkPhysicalDeviceMemoryProperties2 device_memory_properties;
+  device_memory_properties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
+  device_memory_properties.pNext = &physical_device_memory_budget_properties;
+
+  (*rh.vkGetPhysicalDeviceMemoryProperties2)(devices[i], &device_memory_properties);
+
+  VkDeviceSize device_memory_total_size  = 0;
+  VkDeviceSize device_memory_heap_budget = 0;
+
+  for (uint32_t j = 0; j < device_memory_properties.memoryProperties.memoryHeapCount; j++) {
+    VkMemoryHeap heap = device_memory_properties.memoryProperties.memoryHeaps[j];
+    if (heap.flags & VK_MEMORY_HEAP_DEVICE_LOCAL_BIT) {
+      device_memory_total_size  += heap.size;
+      device_memory_heap_budget += physical_device_memory_budget_properties.heapBudget[j];
+    }
+  }
+
+  resp->err = NULL;
+  snprintf(&resp->gpu_id[0], GPU_ID_LEN, "%d", i);
+  resp->gpu_name[GPU_NAME_LEN - 1] = '\0';
+  strncpy(&resp->gpu_name[0], properties.deviceName, GPU_NAME_LEN - 1);
+  resp->total = (uint64_t) device_memory_total_size;
+  resp->free = (uint64_t) device_memory_heap_budget;
+  resp->major = VK_API_VERSION_MAJOR(properties.apiVersion);
+  resp->minor = VK_API_VERSION_MINOR(properties.apiVersion);
+  resp->patch = VK_API_VERSION_PATCH(properties.apiVersion);
+}
+
+void vk_release(vk_handle_t rh) {
+  LOG(rh.verbose, "releasing vulkan library\n");
+  (*rh.vkDestroyInstance)(rh.vk, NULL);
+  UNLOAD_LIBRARY(rh.vk_handle);
+  rh.vk_handle = NULL;
+#ifdef __linux__
+  LOG(rh.verbose, "releasing libcap library\n");
+  UNLOAD_LIBRARY(rh.cap_handle);
+  rh.cap_handle = NULL;
+#endif
+}
diff --git a/discover/gpu_info_vulkan.h b/discover/gpu_info_vulkan.h
new file mode 100644
index 00000000..6025f3e0
--- /dev/null
+++ b/discover/gpu_info_vulkan.h
@@ -0,0 +1,66 @@
+#ifndef __APPLE__
+#ifndef __GPU_INFO_VULKAN_H__
+#define __GPU_INFO_VULKAN_H__
+
+#include "gpu_info.h"
+
+#ifdef __linux__
+#include <sys/capability.h>
+#endif
+
+#include <vulkan/vulkan.h>
+
+typedef struct {
+  void* vk_handle;
+  void* cap_handle;
+  uint16_t verbose;
+
+  VkInstance vk;
+  int num_devices;
+
+#ifdef __linux__
+  cap_t (*cap_get_proc)(void);
+
+  int (*cap_get_bound)(cap_value_t);
+  int (*cap_set_flag)(cap_t, cap_flag_t, int, const cap_value_t *, cap_flag_value_t);
+  int (*cap_set_proc)(cap_t);
+  int (*cap_free)(cap_t);
+#endif
+
+  void (*vkGetPhysicalDeviceProperties)(
+    VkPhysicalDevice                            physicalDevice,
+    VkPhysicalDeviceProperties*                 pProperties);
+  VkResult (*vkEnumerateDeviceExtensionProperties)(
+      VkPhysicalDevice                            physicalDevice,
+      const char*                                 pLayerName,
+      uint32_t*                                   pPropertyCount,
+      VkExtensionProperties*                      pProperties);
+  VkResult (*vkCreateInstance)(
+      const VkInstanceCreateInfo*                 pCreateInfo,
+      const VkAllocationCallbacks*                pAllocator,
+      VkInstance*                                 pInstance);
+  VkResult (*vkEnumeratePhysicalDevices)(
+      VkInstance                                  instance,
+      uint32_t*                                   pPhysicalDeviceCount,
+      VkPhysicalDevice*                           pPhysicalDevices);
+  void (*vkGetPhysicalDeviceMemoryProperties2)(
+      VkPhysicalDevice                            physicalDevice,
+      VkPhysicalDeviceMemoryProperties2*          pMemoryProperties);
+  void (*vkDestroyInstance)(
+      VkInstance                                  instance,
+      const VkAllocationCallbacks*                pAllocator);
+} vk_handle_t;
+
+typedef struct vk_init_resp
+{
+  char *err; // If err is non-null handle is invalid
+  int num_devices;
+  vk_handle_t ch;
+} vk_init_resp_t;
+
+void vk_init(char* vk_lib_path, char* cap_lib_path, vk_init_resp_t *resp);
+void vk_check_vram(vk_handle_t rh, int i, mem_info_t *resp);
+void vk_release(vk_handle_t rh);
+
+#endif
+#endif
\ No newline at end of file
diff --git a/discover/gpu_linux.go b/discover/gpu_linux.go
index d636a54e..a2c1d871 100644
--- a/discover/gpu_linux.go
+++ b/discover/gpu_linux.go
@@ -52,8 +52,26 @@ var (
 	NvcudaMgmtName = "libcuda.so*"
 	NvmlMgmtName   = "" // not currently wired on linux
 	OneapiMgmtName = "libze_intel_gpu.so*"
+	VulkanMgmtName = "libvulkan.so*"
+	libcapMgmtName = "libcap.so*"
 )
 
+var VulkanGlobs = []string{
+	"/usr/lib/x86_64-linux-gnu/libvulkan.so*",
+	"/usr/lib/aarch64-linux-gnu/libvulkan.so*",
+	"/usr/lib*/libvulkan.so*",
+}
+
+var capLinuxGlobs = []string{
+	"/usr/lib/x86_64-linux-gnu/libcap.so*",
+	"/usr/lib/aarch64-linux-gnu/libcap.so*",
+	"/usr/lib*/libcap.so*",
+}
+
+func FindLibCapLibs() []string {
+	return FindGPULibs(libcapMgmtName, capLinuxGlobs)
+}
+
 func GetCPUMem() (memInfo, error) {
 	var mem memInfo
 	var total, available, free, buffers, cached, freeSwap uint64
diff --git a/discover/gpu_windows.go b/discover/gpu_windows.go
index 2dc2f074..d2a4d50c 100644
--- a/discover/gpu_windows.go
+++ b/discover/gpu_windows.go
@@ -42,13 +42,22 @@ var OneapiGlobs = []string{
 	"c:\\Windows\\System32\\DriverStore\\FileRepository\\*\\ze_intel_gpu64.dll",
 }
 
+var VulkanGlobs = []string{
+	"c:\\Windows\\System32\\vulkan-1.dll",
+}
+
 var (
 	CudartMgmtName = "cudart64_*.dll"
 	NvcudaMgmtName = "nvcuda.dll"
 	NvmlMgmtName   = "nvml.dll"
 	OneapiMgmtName = "ze_intel_gpu64.dll"
+	VulkanMgmtName = "vulkan-1.dll"
 )
 
+func FindLibCapLibs() []string {
+	return []string{"<unused>"}
+}
+
 func GetCPUMem() (memInfo, error) {
 	memStatus := MEMORYSTATUSEX{length: sizeofMemoryStatusEx}
 	r1, _, err := globalMemoryStatusExProc.Call(uintptr(unsafe.Pointer(&memStatus)))
diff --git a/discover/types.go b/discover/types.go
index 4568e3b8..417f8ce7 100644
--- a/discover/types.go
+++ b/discover/types.go
@@ -93,6 +93,13 @@ type OneapiGPUInfo struct {
 }
 type OneapiGPUInfoList []OneapiGPUInfo
 
+type VulkanGPUInfo struct {
+	GpuInfo
+	index int
+}
+
+type VulkanGPUInfoList []VulkanGPUInfo
+
 type GpuInfoList []GpuInfo
 
 type UnsupportedGPUInfo struct {
diff --git a/discover/vulkan_common.go b/discover/vulkan_common.go
new file mode 100644
index 00000000..4dccbade
--- /dev/null
+++ b/discover/vulkan_common.go
@@ -0,0 +1,19 @@
+package discover
+
+import (
+	"log/slog"
+	"strings"
+)
+
+func vkGetVisibleDevicesEnv(gpuInfo []GpuInfo) (string, string) {
+	ids := []string{}
+	for _, info := range gpuInfo {
+		if info.Library != "vulkan" {
+			// TODO shouldn't happen if things are wired correctly...
+			slog.Debug("vkGetVisibleDevicesEnv skipping over non-vulkan device", "library", info.Library)
+			continue
+		}
+		ids = append(ids, info.ID)
+	}
+	return "GGML_VK_VISIBLE_DEVICES", strings.Join(ids, ",")
+}
diff --git a/envconfig/config.go b/envconfig/config.go
index c10095a6..831a3a73 100644
--- a/envconfig/config.go
+++ b/envconfig/config.go
@@ -179,6 +179,7 @@ var (
 	CudaVisibleDevices    = String("CUDA_VISIBLE_DEVICES")
 	HipVisibleDevices     = String("HIP_VISIBLE_DEVICES")
 	RocrVisibleDevices    = String("ROCR_VISIBLE_DEVICES")
+	VkVisibleDevices      = String("GGML_VK_VISIBLE_DEVICES")
 	GpuDeviceOrdinal      = String("GPU_DEVICE_ORDINAL")
 	HsaOverrideGfxVersion = String("HSA_OVERRIDE_GFX_VERSION")
 )
@@ -268,6 +269,7 @@ func AsMap() map[string]EnvVar {
 		ret["CUDA_VISIBLE_DEVICES"] = EnvVar{"CUDA_VISIBLE_DEVICES", CudaVisibleDevices(), "Set which NVIDIA devices are visible"}
 		ret["HIP_VISIBLE_DEVICES"] = EnvVar{"HIP_VISIBLE_DEVICES", HipVisibleDevices(), "Set which AMD devices are visible by numeric ID"}
 		ret["ROCR_VISIBLE_DEVICES"] = EnvVar{"ROCR_VISIBLE_DEVICES", RocrVisibleDevices(), "Set which AMD devices are visible by UUID or numeric ID"}
+		ret["GGML_VK_VISIBLE_DEVICES"] = EnvVar{"GGML_VK_VISIBLE_DEVICES", VkVisibleDevices(), "Set which VK AMD devices are visible by numeric ID"}
 		ret["GPU_DEVICE_ORDINAL"] = EnvVar{"GPU_DEVICE_ORDINAL", GpuDeviceOrdinal(), "Set which AMD devices are visible by numeric ID"}
 		ret["HSA_OVERRIDE_GFX_VERSION"] = EnvVar{"HSA_OVERRIDE_GFX_VERSION", HsaOverrideGfxVersion(), "Override the gfx used for all detected AMD GPUs"}
 		ret["OLLAMA_INTEL_GPU"] = EnvVar{"OLLAMA_INTEL_GPU", IntelGPU(), "Enable experimental Intel GPU detection"}
